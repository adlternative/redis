1. redis的`sdstemplate`和git的`strbuf_expand`都是将`{var} {var2}`的内容进行了一次解析，第二个参数cb_func会针对`var`,`var2`这些不同的格式名称进行相应的解析（不过这个是用户放入的函数，灵活性非常强）
2. redis中的`sdssplitlen`和git中的`strbuf_split`的策略是一样的，动态分配一定大小的数组，然后再每次遇上分割符号后将分割段写入到动态数组中，然后空间如果不足再扩容，出错则`goto`+`free`,这解决了我自己当年写的丑陋字符串的疑惑。
3. redis中`sdscatfmt`的可以以它自己的格式而不是printf族那样子去解析传入的可变参数，好处是速度快（因为需要解析的内容少），
4. snprintf:如果在printf上使用format，
        则使用与要打印的文本相同的字符串组成一个字符串，
        但是内容不是作为打印的，而是作为C字符串存储在s所指向的缓冲区中
        （将n作为要填充的最大缓冲区容量）。
        如果结果字符串的长度大于n-1个字符，
        则剩余的字符将被丢弃而不存储，但将被计算为该函数返回的值。
        写入内容后会自动添加一个终止的空字符。
        在format参数之后，该函数至少需要与format所需数量一样多的附加参数。
5. 由于redis使用了不同的类型的sds,这些不同的sds在容量变化的同时可能会发生类型变化，这时候是需要对原有的sds迁移到新的sds的最前面。


总结:无论是`sds`抄`strbuf`，还是`strbuf`抄`sds`，这些c语言开源库实现的字符串类就那几个重要的接口，这些字符串类都是支持动态扩容的，在我们的c程序中可以学习这些内容。